<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>IPTV Cast Receiver</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
        }

        cast-media-player {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Hide default CAF splash/watermark during custom HLS playback */
        .custom-playback cast-media-player {
            visibility: hidden;
        }

        video#hlsVideo {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            background: #000;
            z-index: 10;
            display: none;
        }

        .custom-playback video#hlsVideo {
            display: block;
        }
    </style>
</head>

<body>
    <!-- CAF's built-in media player element â€” handles non-HLS natively -->
    <cast-media-player></cast-media-player>

    <!-- Separate video element for custom HLS playback via hls.js -->
    <video id="hlsVideo" autoplay></video>

    <!-- hls.js for HLS streams -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.5.7"></script>

    <!-- Google Cast Receiver SDK v3 -->
    <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>

    <script>
        'use strict';

        const TAG = '[Receiver]';
        const hlsVideo = document.getElementById('hlsVideo');
        let hls = null;
        let customPlayback = false; // true when WE manage playback (HLS via hls.js)

        const context = cast.framework.CastReceiverContext.getInstance();
        const playerManager = context.getPlayerManager();

        console.log(TAG, 'ğŸš€ Custom IPTV receiver starting...');

        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // Helper: clean up HLS playback
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        function cleanup() {
            if (hls) {
                hls.destroy();
                hls = null;
            }
            customPlayback = false;
            document.body.classList.remove('custom-playback');
            hlsVideo.removeAttribute('src');
            hlsVideo.load();
        }

        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // Intercept LOAD â€” only custom-handle HLS
        // Let CAF handle everything else natively
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        playerManager.setMessageInterceptor(
            cast.framework.messages.MessageType.LOAD,
            (request) => {
                const url = request.media.contentUrl || request.media.contentId;
                const contentType = (request.media.contentType || '').toLowerCase();
                console.log(TAG, 'ğŸ“¥ LOAD:', url);
                console.log(TAG, 'ğŸ“¦ type:', contentType);

                cleanup();

                const isHls = url && (
                    url.includes('.m3u8') ||
                    contentType.includes('mpegurl')
                );

                if (isHls && Hls.isSupported()) {
                    // â”€â”€â”€ HLS via hls.js â”€â”€â”€
                    console.log(TAG, 'ğŸ¬ Using hls.js for HLS');
                    customPlayback = true;
                    document.body.classList.add('custom-playback');

                    return new Promise((resolve) => {
                        hls = new Hls({
                            debug: false,
                            enableWorker: true,
                            lowLatencyMode: false,
                            backBufferLength: 30,
                            maxBufferLength: 30,
                            maxMaxBufferLength: 60,
                            startLevel: -1,
                            fragLoadingMaxRetry: 10,
                            manifestLoadingMaxRetry: 6,
                            levelLoadingMaxRetry: 6,
                            fragLoadingRetryDelay: 1000,
                        });

                        hls.on(Hls.Events.MANIFEST_PARSED, (e, data) => {
                            console.log(TAG, 'âœ… Manifest parsed, levels:', data.levels.length);
                            hlsVideo.play().catch(err =>
                                console.warn(TAG, 'âš ï¸ Autoplay:', err.message)
                            );
                        });

                        hls.on(Hls.Events.ERROR, (e, data) => {
                            console.error(TAG, 'âŒ HLS error:', data.type, data.details);
                            if (data.fatal) {
                                if (data.type === Hls.ErrorTypes.NETWORK_ERROR) {
                                    console.log(TAG, 'ğŸ”„ Retrying...');
                                    hls.startLoad();
                                } else if (data.type === Hls.ErrorTypes.MEDIA_ERROR) {
                                    console.log(TAG, 'ğŸ”„ Recovering media...');
                                    hls.recoverMediaError();
                                } else {
                                    console.error(TAG, 'ğŸ’€ Fatal error');
                                    cleanup();
                                }
                            }
                        });

                        hls.loadSource(url);
                        hls.attachMedia(hlsVideo);
                        resolve(null); // Prevent CAF default loading
                    });

                } else {
                    // â”€â”€â”€ Let CAF handle natively (MP4, TS, MKV, etc.) â”€â”€â”€
                    console.log(TAG, 'ğŸ“º Letting CAF handle natively:', contentType);

                    // For non-standard containers, override content type
                    // so CAF tries its best with its media pipeline
                    if (contentType.includes('matroska') ||
                        contentType.includes('msvideo') ||
                        contentType.includes('quicktime') ||
                        contentType === '') {
                        console.log(TAG, 'ğŸ”€ Overriding content type to video/mp4 for CAF');
                        request.media.contentType = 'video/mp4';
                    }

                    // Let CAF handle it â€” return the request as-is
                    return request;
                }
            }
        );

        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // Handle controls from sender app
        // Only intercept when using custom HLS playback
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        playerManager.setMessageInterceptor(
            cast.framework.messages.MessageType.PAUSE,
            (request) => {
                if (customPlayback) { hlsVideo.pause(); return null; }
                return request;
            }
        );

        playerManager.setMessageInterceptor(
            cast.framework.messages.MessageType.PLAY,
            (request) => {
                if (customPlayback) { hlsVideo.play(); return null; }
                return request;
            }
        );

        playerManager.setMessageInterceptor(
            cast.framework.messages.MessageType.SEEK,
            (request) => {
                if (customPlayback && request.currentTime !== undefined) {
                    hlsVideo.currentTime = request.currentTime;
                    return null;
                }
                return request;
            }
        );

        playerManager.setMessageInterceptor(
            cast.framework.messages.MessageType.STOP,
            (request) => {
                if (customPlayback) { cleanup(); return null; }
                return request;
            }
        );

        playerManager.setMessageInterceptor(
            cast.framework.messages.MessageType.SET_VOLUME,
            (request) => {
                if (customPlayback && request.volume) {
                    if (request.volume.level !== undefined) hlsVideo.volume = request.volume.level;
                    if (request.volume.muted !== undefined) hlsVideo.muted = request.volume.muted;
                    return null;
                }
                return request;
            }
        );

        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // Debug logging
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        hlsVideo.addEventListener('playing', () => console.log(TAG, 'ğŸ‰ PLAYING'));
        hlsVideo.addEventListener('pause', () => console.log(TAG, 'â¸ï¸ PAUSED'));
        hlsVideo.addEventListener('error', () => console.error(TAG, 'âŒ Error:', hlsVideo.error?.message));
        hlsVideo.addEventListener('waiting', () => console.log(TAG, 'â³ BUFFERING'));
        hlsVideo.addEventListener('loadeddata', () => console.log(TAG, 'ğŸ“¦ Data loaded'));

        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // Start
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        const options = new cast.framework.CastReceiverOptions();
        options.disableIdleTimeout = true;
        // Do NOT set options.mediaElement â€” let CAF use its own <cast-media-player>
        // for non-HLS content. We use a separate #hlsVideo element for HLS.

        context.start(options);
        console.log(TAG, 'âœ… Receiver started');
    </script>
</body>

</html>