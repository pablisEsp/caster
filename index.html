<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>IPTV Cast Receiver</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
        }

        video {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            background: #000;
        }
    </style>
</head>

<body>
    <video id="media" autoplay></video>

    <!-- hls.js for HLS streams -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.5.7"></script>

    <!-- Google Cast Receiver SDK v3 -->
    <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>

    <script>
        'use strict';

        const TAG = '[Receiver]';
        const video = document.getElementById('media');
        let hls = null;
        let customPlayback = false; // true when WE manage playback (not CAF)

        const context = cast.framework.CastReceiverContext.getInstance();
        const playerManager = context.getPlayerManager();

        console.log(TAG, 'ğŸš€ Custom IPTV receiver starting...');

        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // Helper: clean up current playback
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        function cleanup() {
            if (hls) {
                hls.destroy();
                hls = null;
            }
            video.removeAttribute('src');
            video.load();
            customPlayback = false;
        }

        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // Intercept LOAD â€” route to hls.js or native
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        playerManager.setMessageInterceptor(
            cast.framework.messages.MessageType.LOAD,
            (request) => {
                const url = request.media.contentUrl || request.media.contentId;
                const contentType = (request.media.contentType || '').toLowerCase();
                console.log(TAG, 'ğŸ“¥ LOAD:', url);
                console.log(TAG, 'ğŸ“¦ type:', contentType);

                cleanup();

                const isHls = url && (
                    url.includes('.m3u8') ||
                    contentType.includes('mpegurl')
                );

                if (isHls && Hls.isSupported()) {
                    // â”€â”€â”€ HLS via hls.js â”€â”€â”€
                    console.log(TAG, 'ğŸ¬ Using hls.js for HLS');
                    customPlayback = true;

                    return new Promise((resolve) => {
                        hls = new Hls({
                            debug: false,
                            enableWorker: true,
                            lowLatencyMode: false,
                            backBufferLength: 30,
                            maxBufferLength: 30,
                            maxMaxBufferLength: 60,
                            startLevel: -1,
                            fragLoadingMaxRetry: 10,
                            manifestLoadingMaxRetry: 6,
                            levelLoadingMaxRetry: 6,
                            fragLoadingRetryDelay: 1000,
                        });

                        hls.on(Hls.Events.MANIFEST_PARSED, (e, data) => {
                            console.log(TAG, 'âœ… Manifest parsed, levels:', data.levels.length);
                            video.play().catch(err =>
                                console.warn(TAG, 'âš ï¸ Autoplay:', err.message)
                            );
                        });

                        hls.on(Hls.Events.ERROR, (e, data) => {
                            console.error(TAG, 'âŒ HLS error:', data.type, data.details);
                            if (data.fatal) {
                                if (data.type === Hls.ErrorTypes.NETWORK_ERROR) {
                                    console.log(TAG, 'ğŸ”„ Retrying...');
                                    hls.startLoad();
                                } else if (data.type === Hls.ErrorTypes.MEDIA_ERROR) {
                                    console.log(TAG, 'ğŸ”„ Recovering media...');
                                    hls.recoverMediaError();
                                } else {
                                    console.error(TAG, 'ğŸ’€ Fatal error');
                                    cleanup();
                                }
                            }
                        });

                        hls.loadSource(url);
                        hls.attachMedia(video);
                        resolve(null); // Prevent CAF default loading
                    });

                } else {
                    // â”€â”€â”€ Direct video (MP4, TS, etc.) â”€â”€â”€
                    console.log(TAG, 'ğŸ“º Using direct video playback for:', url);
                    customPlayback = true;

                    video.src = url;
                    video.load();
                    video.play().then(() => {
                        console.log(TAG, 'â–¶ï¸ Direct playback started');
                    }).catch(err => {
                        console.error(TAG, 'âŒ Direct play failed:', err.message);
                    });

                    return null; // Prevent CAF default loading
                }
            }
        );

        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // Handle controls from sender app
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        playerManager.setMessageInterceptor(
            cast.framework.messages.MessageType.PAUSE,
            (request) => {
                if (customPlayback) { video.pause(); return null; }
                return request;
            }
        );

        playerManager.setMessageInterceptor(
            cast.framework.messages.MessageType.PLAY,
            (request) => {
                if (customPlayback) { video.play(); return null; }
                return request;
            }
        );

        playerManager.setMessageInterceptor(
            cast.framework.messages.MessageType.SEEK,
            (request) => {
                if (customPlayback && request.currentTime !== undefined) {
                    video.currentTime = request.currentTime;
                    return null;
                }
                return request;
            }
        );

        playerManager.setMessageInterceptor(
            cast.framework.messages.MessageType.STOP,
            (request) => {
                if (customPlayback) { cleanup(); return null; }
                return request;
            }
        );

        playerManager.setMessageInterceptor(
            cast.framework.messages.MessageType.SET_VOLUME,
            (request) => {
                if (customPlayback && request.volume) {
                    if (request.volume.level !== undefined) video.volume = request.volume.level;
                    if (request.volume.muted !== undefined) video.muted = request.volume.muted;
                    return null;
                }
                return request;
            }
        );

        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // Debug logging
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        video.addEventListener('playing', () => console.log(TAG, 'ğŸ‰ PLAYING'));
        video.addEventListener('pause', () => console.log(TAG, 'â¸ï¸ PAUSED'));
        video.addEventListener('error', () => console.error(TAG, 'âŒ Error:', video.error?.message));
        video.addEventListener('waiting', () => console.log(TAG, 'â³ BUFFERING'));
        video.addEventListener('loadeddata', () => console.log(TAG, 'ğŸ“¦ Data loaded'));

        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // Start
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        const options = new cast.framework.CastReceiverOptions();
        options.disableIdleTimeout = true;
        options.mediaElement = video;

        context.start(options);
        console.log(TAG, 'âœ… Receiver started');
    </script>
</body>

</html>